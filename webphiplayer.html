<html>
    <body>
        <label class="nocanvas" for="chartInput">请选择谱面文件: </label><input class="chartInput nocanvas" type="file"><br>
        <label class="nocanvas" for="audioInput">请选择音频文件: </label><input class="audioInput nocanvas" type="file"><br>
        <label class="nocanvas" for="imageInput">请选择背景图片: </label><input class="imageInput nocanvas" type="file"><br>
        <button class="startButton nocanvas">开始</button>
        <audio class="mainAudio"></audio>
        <img class="resImg tap" src="./Resources/Notes/Tap.png">
        <img class="resImg tapDub" src="./Resources/Notes/Tap_dub.png">
        <img class="resImg drag" src="./Resources/Notes/Drag.png">
        <img class="resImg dragDub" src="./Resources/Notes/Drag_dub.png">
        <img class="resImg flick" src="./Resources/Notes/Flick.png">
        <img class="resImg flickDub" src="./Resources/Notes/Flick_dub.png">
        <img class="resImg holdHead" src="./Resources/Notes/Hold_Head.png">
        <img class="resImg holdHeadDub" src="./Resources/Notes/Hold_Body_dub.png">
        <img class="resImg holdBody" src="./Resources/Notes/Hold_Body.png">
        <img class="resImg holdBodyDub" src="./Resources/Notes/Hold_Body_dub.png">
        <img class="resImg holdEnd" src="./Resources/Notes/Hold_End.png">
        <img class="resImg holdEndDub" src="./Resources/Notes/Hold_End_dub.png">
    </body>
</html>

<style>
    body {
        overflow-x: hidden;
        overflow-y: hidden;
        padding: 0;
        border: 0;
        margin: 0;
    }

    .mainCanvas {
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        position: absolute;
    }

    .mainAudio {
        display: none;
    }

    .resImg {
        display: none;
    }
</style>

<script>
    const chartAudio = document.querySelector(".mainAudio");
    const Res_Tap = document.querySelector(".resImg.tap");
    const Res_TapDub = document.querySelector(".resImg.tapDub");
    const Res_Drag = document.querySelector(".resImg.drag");
    const Res_DragDub = document.querySelector(".resImg.dragDub");
    const Res_Flick = document.querySelector(".resImg.flick");
    const Res_FlickDub = document.querySelector(".resImg.flickDub");
    const Res_HoldHead = document.querySelector(".resImg.holdHead");
    const Res_HoldHeadDub = document.querySelector(".resImg.holdHeadDub");
    const Res_HoldBody = document.querySelector(".resImg.holdBody");
    const Res_HoldBodyDub = document.querySelector(".resImg.holdBodyDub");
    const Res_HoldEnd = document.querySelector(".resImg.holdEnd");
    const Res_HoldEndDub = document.querySelector(".resImg.holdEndDub");

    var loaded_chart = false;
    var loaded_image = false;

    function initCanvas() {
        cv = document.createElement("canvas");
        cv.className = "mainCanvas";
        document.body.appendChild(cv);
        ctx = cv.getContext("2d", {alpha: false});
        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();
    }
    
    function resizeCanvas() {
        cv.width = window.innerWidth * window.devicePixelRatio;
        cv.height = window.innerHeight * window.devicePixelRatio;
        w = cv.width;
        h = cv.height;
        Note_width = (0.125 * w + 0.2 * h) / 2;
        Note_MaxSize = Math.sqrt(Note_width ** 2 * 2);
    }

    function linearInterpolation(sv, ev, st, et, t) {
        return (t - st) / (et - st) * (ev - sv) + sv;
    }

    function rotatePoint(x, y, deg, r) {
        return [
            x + r * Math.cos(deg / 180 * Math.PI),
            y + r * Math.sin(deg / 180 * Math.PI)
        ];
    }

    function start() {
        chartAudio.play();
        initCanvas();

        if (chartData.formatVersion) phiRender();
        else rpeRender();
    }

    function getPhiFP(line, t) {
        let result = 0.0;
        for (e of line.speedEvents) {
            if (e.endTime <= t) {
                result += (e.endTime - e.startTime) * e.value;
            }
            else if (e.startTime <= t && t <= e.endTime) {
                result += (t - e.startTime) * e.value;
            }
        }
        return result * h * 0.6 * (1.875 / line.bpm);
    }

    function is_intersect(line_1, line_2) {
        return ! (
            Math.max(line_1[0][0], line_1[1][0]) < Math.min(line_2[0][0], line_2[1][0]) ||
            Math.max(line_2[0][0], line_2[1][0]) < Math.min(line_1[0][0], line_1[1][0]) ||
            Math.max(line_1[0][1], line_1[1][1]) < Math.min(line_2[0][1], line_2[1][1]) ||
            Math.max(line_2[0][1], line_2[1][1]) < Math.min(line_1[0][1], line_1[1][1])
        )
    }

    function batch_is_intersect(linesGroup1, linesGroup2) {
        let results = [];
        for (i of linesGroup1) {
            for (j of linesGroup2) {
                results.push(is_intersect(i, j));
            }
        }
        return results;
    }

    function noteCanRender_Hold(x, y, holdBodyRange) {
        for (point of holdBodyRange) {
            if (noteCanRender_Note(...point)) return true;
        }

        return batch_is_intersect(
            [
                [holdBodyRange[0], holdBodyRange[1]],
                [holdBodyRange[1], holdBodyRange[2]],
                [holdBodyRange[2], holdBodyRange[3]],
                [holdBodyRange[3], holdBodyRange[0]]
            ],
            [
                [[0, 0], [w, 0]], [[0, 0], [0, h]],
                [[w, 0], [w, h]], [[0, h], [w, h]]
            ]
        ).some((e) => e);
    }

    function noteCanRender_Note(x, y) {
        return (
            -Note_MaxSize / 2 <= x &&
            x <= w + Note_MaxSize / 2 &&
            -Note_MaxSize / 2 <= y &&
            y <= h + Note_MaxSize / 2
        );
    }

    function phiRender() {
        curTime = chartAudio.currentTime;
        lineRotate = 0.0; lineAlpha = 0.0; lineX = 0.0; lineY = 0.0;

        ctx.clear();
        ctx.drawImage(chartImage, 0, 0, w, h);

        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
        
        for (line of chartData.judgeLineList) {
            lineT = 1.875 / line.bpm;
            lineRotate = 0.0; lineAlpha = 0.0; lineX = 0.0; lineY = 0.0;
            curBTime = curTime / (lineT);

            for (e of line.judgeLineRotateEvents) {
                if (e.startTime <= curBTime && curBTime <= e.endTime) {
                    lineRotate = - linearInterpolation(e.start, e.end, e.startTime, e.endTime, curBTime);
                    break;
                }
            }

            for (e of line.judgeLineDisappearEvents) {
                if (e.startTime <= curBTime && curBTime <= e.endTime) {
                    lineAlpha = linearInterpolation(e.start, e.end, e.startTime, e.endTime, curBTime);
                    break;
                }
            }

            for (e of line.judgeLineMoveEvents) {
                if (e.startTime <= curBTime && curBTime <= e.endTime) {
                    lineX = linearInterpolation(e.start, e.end, e.startTime, e.endTime, curBTime) * w;
                    lineY = (1.0 - linearInterpolation(e.start2, e.end2, e.startTime, e.endTime, curBTime)) * h;
                    break;
                }
            }

            [lineX1, lineY1] = rotatePoint(lineX, lineY, lineRotate, h * 5.76 / 2);
            [lineX2, lineY2] = rotatePoint(lineX, lineY, lineRotate + 180, h * 5.76 / 2);
            ctx.drawLineEx(lineX1, lineY1, lineX2, lineY2, h * 0.0075, `rgba(254, 255, 169, ${lineAlpha})`);

            lineFPosition = getPhiFP(line, curBTime);

            _rnotes = (notes, above) => {
                for (note of notes) {
                    if ((note.time < curBTime && note.type != 3) || ((note.time + note.holdTime) < curBTime && note.type == 3)) continue;
                    noteFloorPosition = note.floorPosition * h * 0.6 - (
                        (!(note.type == 3 && note.time < curBTime)) ? lineFPosition : (
                            getPhiFP(line, note.time) * h * 0.6 + linearInterpolation(
                                note.speed * (note.holdTime * lineT) * h * 0.6, 0.0,
                                0.0, note.holdTime,
                                note.time + note.holdTime - curBTime,
                            )
                        )
                    );

                    if (noteFloorPosition > h * 2) continue;

                    [noteAtLineX, noteAtLineY] = rotatePoint(lineX, lineY, lineRotate, note.positionX * w * 0.05625);
                    lineToNoteRotateDeg = (above ? -90 : 90) + lineRotate;
                    [x, y] = rotatePoint(noteAtLineX, noteAtLineY, lineToNoteRotateDeg, noteFloorPosition);

                    if (note.type == 3) {
                        holdDrawLength = noteFloorPosition + note.speed * (note.holdTime * lineT) * h * 0.6;
                        [holdEndX, holdEndY] = rotatePoint(noteAtLineX, noteAtLineY, lineToNoteRotateDeg, holdDrawLength);
                        if (note.time < curBTime) [holdHeadX, holdHeadY] = [noteAtLineX, noteAtLineY];
                        else [holdHeadX, holdHeadY] = [x, y];
                        holdBodyRange = [
                            rotatePoint(holdHeadX, holdHeadY, lineToNoteRotateDeg - 90, Note_width / 2),
                            rotatePoint(holdEndX, holdEndY, lineToNoteRotateDeg - 90, Note_width / 2),
                            rotatePoint(holdEndX, holdEndY, lineToNoteRotateDeg + 90, Note_width / 2),
                            rotatePoint(holdHeadX, holdHeadY, lineToNoteRotateDeg + 90, Note_width / 2)
                        ];
                    }
                    
                    if (note.type == 3 ? noteCanRender_Hold(x, y, holdBodyRange) : noteCanRender_Note(x, y)) {
                        noteRotate = lineToNoteRotateDeg + 90;

                        if (note.type != 3) {
                            noteImg = eval(`Res_${["Tap", "Drag", null, "Flick"][note.type - 1]}${"Dub"}`);

                            thisNoteWidth = Note_width * 1.0;
                            thisNoteHeight = Note_width / noteImg.width * noteImg.height;

                            ctx.drawRotateImage(
                                noteImg,
                                x, y, thisNoteWidth, thisNoteHeight,
                                noteRotate, 1.0
                            );
                        }
                    }
                }
            };

            _rnotes(line.notesAbove, true);
            _rnotes(line.notesBelow, false);
        }

        requestAnimationFrame(phiRender);
    }

    function rpeRender() {

    }

    CanvasRenderingContext2D.prototype.drawLineEx = function (x1, y1, x2, y2, width, color) {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
    }

    CanvasRenderingContext2D.prototype.drawRotateImage = function(im, x, y, width, height, deg, alpha) { // draw at the position center
        this.save();
        this.globalAlpha *= alpha;
        if (!!deg){
            this.translate(x,y);
            this.rotate(deg * Math.PI / 180);
            this.drawImage(im, -width / 2, -height / 2, width, height);
        }
        else {
            this.drawImage(im, x - width / 2, y - height / 2, width, height);
        }
        this.restore();
    }

    CanvasRenderingContext2D.prototype.clear = function() {
        this.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    document.querySelector(".startButton").addEventListener("click", () => {
        let chartFile = document.querySelector(".chartInput").files[0];
        let audioFile = document.querySelector(".audioInput").files[0];
        let imageFile = document.querySelector(".imageInput").files[0];

        let chartReader = new FileReader();
        chartReader.onload = (e) => {chartData = JSON.parse(chartReader.result); loaded_chart = true};
        chartReader.readAsText(chartFile);

        chartAudio.src = URL.createObjectURL(audioFile);

        chartImage = new Image();
        chartImage.onload = () => {loaded_image = true};
        chartImage.src = URL.createObjectURL(imageFile);

        let checker = () => {
            if (loaded_chart && loaded_image) {
                start();
            }
            else {
                setTimeout(checker, 1000 / 60);
            }
        }

        document.querySelectorAll(".nocanvas").forEach((e) => e.remove());
        checker();
    });
</script>